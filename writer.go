package main

import (
	"bytes"
	"fmt"
	"go/format"
	"os"
	"path"
	"strings"
	"text/template"
)

const accessorTemplate = `
{{range .Structs}}
{{$s := .StructName}}
// -----------------------------------------------------------------------------
// {{$s}} Accessors
// -----------------------------------------------------------------------------
{{range .Accessors}}
{{if .HasGetter}}
func (x *{{$s}}) {{.MethodName}}() {{.Type}} {
	return x.{{.Name}}
}
{{end}}
{{if .HasSetter}}
func (x *{{$s}}) Set{{.MethodName}}(v {{.Type}}) bool {
	{{if .HasValidator}}if !x.validate{{.MethodName}}(v) {
		return false
	}
	{{end}}x.{{.Name}} = v
	return true
}
{{end}}
{{end}}
{{end}}
`

const constructorTemplate = `
{{range .Structs}}
{{if .GenerateConstructor}}
/*
func New{{.StructName}}({{range $i, $e := .AllFields}}{{if $i}}, {{end}}{{$e.ArgName}} {{$e.Type}}{{end}}) *{{.StructName}} {
	return &{{.StructName}}{
{{range .AllFields}}		{{.Name}}: {{.ArgName}},
{{end}}	}
}
*/
{{end}}

{{if .GenerateBuilder}}
// -----------------------------------------------------------------------------
// {{.StructName}} Builder
// -----------------------------------------------------------------------------
type {{.StructName}}Builder struct {
	target *{{.StructName}}
}

func New{{.StructName}}Builder() *{{.StructName}}Builder {
	return &{{.StructName}}Builder{
		target: &{{.StructName}}{},
	}
}

func (b *{{.StructName}}Builder) Build() *{{.StructName}} {
	return b.target
}

{{$s := .StructName}}
{{range .AllFields}}
func (b *{{$s}}Builder) {{.Name}}(v {{.Type}}) *{{$s}}Builder {
	b.target.{{.Name}} = v
	return b
}
{{end}}
{{end}}
{{end}}
`

func GenerateFile(data *FileData, outputPath string, isConstructor bool) error {
	tmplStr := accessorTemplate
	if isConstructor {
		tmplStr = constructorTemplate
	}

	// 1. Generate Body
	var bodyBuf bytes.Buffer
	tmpl := template.Must(template.New("body").Parse(tmplStr))
	if err := tmpl.Execute(&bodyBuf, data); err != nil {
		return err
	}
	bodyString := bodyBuf.String()

	// 2. Calculate Imports
	var finalImports []string
	for _, imp := range data.Imports {
		pathLit := imp.Path.Value
		var localName string
		if imp.Name != nil {
			localName = imp.Name.Name
		} else {
			cleanPath := strings.Trim(pathLit, "\"")
			localName = path.Base(cleanPath)
		}

		if strings.Contains(bodyString, localName+".") {
			if imp.Name != nil {
				finalImports = append(finalImports, fmt.Sprintf("%s %s", localName, pathLit))
			} else {
				finalImports = append(finalImports, pathLit)
			}
		}
	}

	// 3. Assemble a VALID Go file in memory
	var fileBuf bytes.Buffer
	fmt.Fprintf(&fileBuf, "// Code generated by GoBoilr; DO NOT EDIT.\n")
	fmt.Fprintf(&fileBuf, "package %s\n\n", data.PackageName)
	writeImports(&fileBuf, finalImports)
	fileBuf.WriteString(bodyString)

	// 4. Format
	formattedBytes, err := format.Source(fileBuf.Bytes())
	if err != nil {
		os.WriteFile(outputPath, fileBuf.Bytes(), 0644)
		return fmt.Errorf("formatting failed: %w", err)
	}

	return os.WriteFile(outputPath, formattedBytes, 0644)
}

func writeImports(buf *bytes.Buffer, imports []string) {
	if len(imports) > 0 {
		fmt.Fprintf(buf, "import (\n")
		for _, imp := range imports {
			fmt.Fprintf(buf, "\t%s\n", imp)
		}
		fmt.Fprintf(buf, ")\n")
	}
}
