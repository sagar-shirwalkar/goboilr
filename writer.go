package main

import (
	"bytes"
	"fmt"
	"os"
	"path"
	"strings"
	"text/template"
)

const accessorTemplate = `
{{range .Structs}}
{{$s := .StructName}}
// -----------------------------------------------------------------------------
// {{$s}} Accessors
// -----------------------------------------------------------------------------
{{range .Accessors}}
{{if .HasGetter}}
func (x *{{$s}}) {{.MethodName}}() {{.Type}} {
	return x.{{.Name}}
}
{{end}}
{{if .HasSetter}}
func (x *{{$s}}) Set{{.MethodName}}(v {{.Type}}) bool {
	{{if .HasValidator}}if !x.validate{{.MethodName}}(v) {
		return false
	}
	{{end}}x.{{.Name}} = v
	return true
}
{{end}}
{{end}}
{{end}}
`

const constructorTemplate = `
/*
{{range .Structs}}
{{if .GenerateConstructor}}
func New{{.StructName}}({{range .AllFields}}{{.ArgName}} {{.Type}}, {{end}}) *{{.StructName}} {
	return &{{.StructName}}{
		{{range .AllFields}}{{.Name}}: {{.ArgName}},
		{{end}}
	}
}
{{end}}
{{end}}
*/
`

func GenerateFile(data *FileData, outputPath string, isConstructor bool) error {
	tmplStr := accessorTemplate
	if isConstructor {
		tmplStr = constructorTemplate
	}

	var bodyBuf bytes.Buffer
	tmpl := template.Must(template.New("body").Parse(tmplStr))
	if err := tmpl.Execute(&bodyBuf, data); err != nil {
		return err
	}
	bodyString := bodyBuf.String()

	var finalImports []string
	for _, imp := range data.Imports {
		pathLit := imp.Path.Value
		var localName string
		if imp.Name != nil {
			localName = imp.Name.Name
		} else {
			cleanPath := strings.Trim(pathLit, "\"")
			localName = path.Base(cleanPath)
		}

		if strings.Contains(bodyString, localName+".") {
			if imp.Name != nil {
				finalImports = append(finalImports, fmt.Sprintf("%s %s", localName, pathLit))
			} else {
				finalImports = append(finalImports, pathLit)
			}
		}
	}

	f, err := os.Create(outputPath)
	if err != nil {
		return err
	}
	defer f.Close()

	fmt.Fprintf(f, "// Code generated by GoBoilr; DO NOT EDIT.\n")
	fmt.Fprintf(f, "package %s\n\n", data.PackageName)

	if isConstructor {
		fmt.Fprintf(f, "/*\n")
		writeImports(f, finalImports)
		raw := strings.TrimSpace(bodyString)
		raw = strings.TrimPrefix(raw, "/*")
		raw = strings.TrimSuffix(raw, "*/")
		f.WriteString(raw)
		fmt.Fprintf(f, "\n*/")
	} else {
		writeImports(f, finalImports)
		f.WriteString(bodyString)
	}

	return nil
}

func writeImports(f *os.File, imports []string) {
	if len(imports) > 0 {
		fmt.Fprintf(f, "import (\n")
		for _, imp := range imports {
			fmt.Fprintf(f, "\t%s\n", imp)
		}
		fmt.Fprintf(f, ")\n")
	}
}
